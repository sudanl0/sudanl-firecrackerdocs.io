<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Represents a continuous region of guest physical memory."><title>GuestMemoryRegion in vmm::vstate::memory - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-4e54bb2b497cc83f.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="vmm" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.0-nightly (a2d9d73e6 2024-01-10)" data-channel="nightly" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-0b2e2def73e61cbe.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../vmm/index.html">vmm</a><span class="version">0.1.0</span></h2></div><h2 class="location"><a href="#">GuestMemoryRegion</a></h2><div class="sidebar-elems"><section><h3><a href="#required-associated-types">Required Associated Types</a></h3><ul class="block"><li><a href="#associatedtype.B">B</a></li></ul><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.bitmap">bitmap</a></li><li><a href="#tymethod.len">len</a></li><li><a href="#tymethod.start_addr">start_addr</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.address_in_range">address_in_range</a></li><li><a href="#method.as_mut_slice">as_mut_slice</a></li><li><a href="#method.as_slice">as_slice</a></li><li><a href="#method.as_volatile_slice">as_volatile_slice</a></li><li><a href="#method.check_address">check_address</a></li><li><a href="#method.checked_offset">checked_offset</a></li><li><a href="#method.file_offset">file_offset</a></li><li><a href="#method.get_host_address">get_host_address</a></li><li><a href="#method.get_slice">get_slice</a></li><li><a href="#method.is_hugetlbfs">is_hugetlbfs</a></li><li><a href="#method.last_addr">last_addr</a></li><li><a href="#method.to_region_addr">to_region_addr</a></li></ul><h3><a href="#object-safety">Object Safety</a></h3><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In vmm::vstate::memory</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../../vmm/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press â€˜Sâ€™ to search, â€˜?â€™ for more optionsâ€¦" type="search"><div id="help-button" tabindex="-1"><a href="../../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Trait <a href="../../index.html">vmm</a>::<wbr><a href="../index.html">vstate</a>::<wbr><a href="index.html">memory</a>::<wbr><a class="trait" href="#">GuestMemoryRegion</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub trait GuestMemoryRegion: <a class="trait" href="trait.Bytes.html" title="trait vmm::vstate::memory::Bytes">Bytes</a>&lt;<a class="struct" href="struct.MemoryRegionAddress.html" title="struct vmm::vstate::memory::MemoryRegionAddress">MemoryRegionAddress</a>, E = Error&gt; {
    type <a href="#associatedtype.B" class="associatedtype">B</a>: <a class="trait" href="trait.Bitmap.html" title="trait vmm::vstate::memory::Bitmap">Bitmap</a>;

<details class="toggle type-contents-toggle"><summary class="hideme"><span>Show 15 methods</span></summary>    // Required methods
    fn <a href="#tymethod.len" class="fn">len</a>(&amp;self) -&gt; &lt;<a class="struct" href="struct.GuestAddress.html" title="struct vmm::vstate::memory::GuestAddress">GuestAddress</a> as <a class="trait" href="address/trait.AddressValue.html" title="trait vmm::vstate::memory::address::AddressValue">AddressValue</a>&gt;::<a class="associatedtype" href="address/trait.AddressValue.html#associatedtype.V" title="type vmm::vstate::memory::address::AddressValue::V">V</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.start_addr" class="fn">start_addr</a>(&amp;self) -&gt; <a class="struct" href="struct.GuestAddress.html" title="struct vmm::vstate::memory::GuestAddress">GuestAddress</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.bitmap" class="fn">bitmap</a>(&amp;self) -&gt; &amp;Self::<a class="associatedtype" href="trait.GuestMemoryRegion.html#associatedtype.B" title="type vmm::vstate::memory::GuestMemoryRegion::B">B</a>;

    // Provided methods
    fn <a href="#method.last_addr" class="fn">last_addr</a>(&amp;self) -&gt; <a class="struct" href="struct.GuestAddress.html" title="struct vmm::vstate::memory::GuestAddress">GuestAddress</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.check_address" class="fn">check_address</a>(
        &amp;self,
        addr: <a class="struct" href="struct.MemoryRegionAddress.html" title="struct vmm::vstate::memory::MemoryRegionAddress">MemoryRegionAddress</a>
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.MemoryRegionAddress.html" title="struct vmm::vstate::memory::MemoryRegionAddress">MemoryRegionAddress</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.address_in_range" class="fn">address_in_range</a>(&amp;self, addr: <a class="struct" href="struct.MemoryRegionAddress.html" title="struct vmm::vstate::memory::MemoryRegionAddress">MemoryRegionAddress</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.checked_offset" class="fn">checked_offset</a>(
        &amp;self,
        base: <a class="struct" href="struct.MemoryRegionAddress.html" title="struct vmm::vstate::memory::MemoryRegionAddress">MemoryRegionAddress</a>,
        offset: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.MemoryRegionAddress.html" title="struct vmm::vstate::memory::MemoryRegionAddress">MemoryRegionAddress</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.to_region_addr" class="fn">to_region_addr</a>(&amp;self, addr: <a class="struct" href="struct.GuestAddress.html" title="struct vmm::vstate::memory::GuestAddress">GuestAddress</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.MemoryRegionAddress.html" title="struct vmm::vstate::memory::MemoryRegionAddress">MemoryRegionAddress</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.get_host_address" class="fn">get_host_address</a>(
        &amp;self,
        _addr: <a class="struct" href="struct.MemoryRegionAddress.html" title="struct vmm::vstate::memory::MemoryRegionAddress">MemoryRegionAddress</a>
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>, Error&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.file_offset" class="fn">file_offset</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="struct.FileOffset.html" title="struct vmm::vstate::memory::FileOffset">FileOffset</a>&gt; { ... }
<span class="item-spacer"></span>    unsafe fn <a href="#method.as_slice" class="fn">as_slice</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt; { ... }
<span class="item-spacer"></span>    unsafe fn <a href="#method.as_mut_slice" class="fn">as_mut_slice</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.get_slice" class="fn">get_slice</a>(
        &amp;self,
        offset: <a class="struct" href="struct.MemoryRegionAddress.html" title="struct vmm::vstate::memory::MemoryRegionAddress">MemoryRegionAddress</a>,
        count: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;VolatileSlice&lt;'_, &lt;Self::<a class="associatedtype" href="trait.GuestMemoryRegion.html#associatedtype.B" title="type vmm::vstate::memory::GuestMemoryRegion::B">B</a> as WithBitmapSlice&lt;'_&gt;&gt;::S&gt;, Error&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.as_volatile_slice" class="fn">as_volatile_slice</a>(
        &amp;self
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;VolatileSlice&lt;'_, &lt;Self::<a class="associatedtype" href="trait.GuestMemoryRegion.html#associatedtype.B" title="type vmm::vstate::memory::GuestMemoryRegion::B">B</a> as WithBitmapSlice&lt;'_&gt;&gt;::S&gt;, Error&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.is_hugetlbfs" class="fn">is_hugetlbfs</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt; { ... }
</details>}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Represents a continuous region of guest physical memory.</p>
</div></details><h2 id="required-associated-types" class="section-header">Required Associated Types<a href="#required-associated-types" class="anchor">Â§</a></h2><div class="methods"><details class="toggle" open><summary><section id="associatedtype.B" class="method"><h4 class="code-header">type <a href="#associatedtype.B" class="associatedtype">B</a>: <a class="trait" href="trait.Bitmap.html" title="trait vmm::vstate::memory::Bitmap">Bitmap</a></h4></section></summary><div class="docblock"><p>Type used for dirty memory tracking.</p>
</div></details></div><h2 id="required-methods" class="section-header">Required Methods<a href="#required-methods" class="anchor">Â§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.len" class="method"><h4 class="code-header">fn <a href="#tymethod.len" class="fn">len</a>(&amp;self) -&gt; &lt;<a class="struct" href="struct.GuestAddress.html" title="struct vmm::vstate::memory::GuestAddress">GuestAddress</a> as <a class="trait" href="address/trait.AddressValue.html" title="trait vmm::vstate::memory::address::AddressValue">AddressValue</a>&gt;::<a class="associatedtype" href="address/trait.AddressValue.html#associatedtype.V" title="type vmm::vstate::memory::address::AddressValue::V">V</a></h4></section></summary><div class="docblock"><p>Returns the size of the region.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.start_addr" class="method"><h4 class="code-header">fn <a href="#tymethod.start_addr" class="fn">start_addr</a>(&amp;self) -&gt; <a class="struct" href="struct.GuestAddress.html" title="struct vmm::vstate::memory::GuestAddress">GuestAddress</a></h4></section></summary><div class="docblock"><p>Returns the minimum (inclusive) address managed by the region.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.bitmap" class="method"><h4 class="code-header">fn <a href="#tymethod.bitmap" class="fn">bitmap</a>(&amp;self) -&gt; &amp;Self::<a class="associatedtype" href="trait.GuestMemoryRegion.html#associatedtype.B" title="type vmm::vstate::memory::GuestMemoryRegion::B">B</a></h4></section></summary><div class="docblock"><p>Borrow the associated <code>Bitmap</code> object.</p>
</div></details></div><h2 id="provided-methods" class="section-header">Provided Methods<a href="#provided-methods" class="anchor">Â§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.last_addr" class="method"><h4 class="code-header">fn <a href="#method.last_addr" class="fn">last_addr</a>(&amp;self) -&gt; <a class="struct" href="struct.GuestAddress.html" title="struct vmm::vstate::memory::GuestAddress">GuestAddress</a></h4></section></summary><div class="docblock"><p>Returns the maximum (inclusive) address managed by the region.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.check_address" class="method"><h4 class="code-header">fn <a href="#method.check_address" class="fn">check_address</a>(
    &amp;self,
    addr: <a class="struct" href="struct.MemoryRegionAddress.html" title="struct vmm::vstate::memory::MemoryRegionAddress">MemoryRegionAddress</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.MemoryRegionAddress.html" title="struct vmm::vstate::memory::MemoryRegionAddress">MemoryRegionAddress</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the given address if it is within this region.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.address_in_range" class="method"><h4 class="code-header">fn <a href="#method.address_in_range" class="fn">address_in_range</a>(&amp;self, addr: <a class="struct" href="struct.MemoryRegionAddress.html" title="struct vmm::vstate::memory::MemoryRegionAddress">MemoryRegionAddress</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the given address is within this region.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.checked_offset" class="method"><h4 class="code-header">fn <a href="#method.checked_offset" class="fn">checked_offset</a>(
    &amp;self,
    base: <a class="struct" href="struct.MemoryRegionAddress.html" title="struct vmm::vstate::memory::MemoryRegionAddress">MemoryRegionAddress</a>,
    offset: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.MemoryRegionAddress.html" title="struct vmm::vstate::memory::MemoryRegionAddress">MemoryRegionAddress</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the address plus the offset if it is in this region.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_region_addr" class="method"><h4 class="code-header">fn <a href="#method.to_region_addr" class="fn">to_region_addr</a>(&amp;self, addr: <a class="struct" href="struct.GuestAddress.html" title="struct vmm::vstate::memory::GuestAddress">GuestAddress</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.MemoryRegionAddress.html" title="struct vmm::vstate::memory::MemoryRegionAddress">MemoryRegionAddress</a>&gt;</h4></section></summary><div class="docblock"><p>Tries to convert an absolute address to a relative address within this region.</p>
<p>Returns <code>None</code> if <code>addr</code> is out of the bounds of this region.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_host_address" class="method"><h4 class="code-header">fn <a href="#method.get_host_address" class="fn">get_host_address</a>(&amp;self, _addr: <a class="struct" href="struct.MemoryRegionAddress.html" title="struct vmm::vstate::memory::MemoryRegionAddress">MemoryRegionAddress</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>, Error&gt;</h4></section></summary><div class="docblock"><p>Returns the host virtual address corresponding to the region address.</p>
<p>Some <a href="trait.GuestMemory.html"><code>GuestMemory</code></a> implementations, like <code>GuestMemoryMmap</code>,
have the capability to mmap guest address range into host virtual address space for
direct access, so the corresponding host virtual address may be passed to other subsystems.</p>
<h5 id="note"><a href="#note">Note</a></h5>
<p>The underlying guest memory is not protected from memory aliasing, which breaks the
Rust memory safety model. Itâ€™s the callerâ€™s responsibility to ensure that thereâ€™s no
concurrent accesses to the underlying guest memory.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.file_offset" class="method"><h4 class="code-header">fn <a href="#method.file_offset" class="fn">file_offset</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="struct.FileOffset.html" title="struct vmm::vstate::memory::FileOffset">FileOffset</a>&gt;</h4></section></summary><div class="docblock"><p>Returns information regarding the file and offset backing this memory region.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_slice" class="method"><h4 class="code-header">unsafe fn <a href="#method.as_slice" class="fn">as_slice</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;</h4></section></summary><span class="item-info"><div class="stab deprecated"><span class="emoji">ðŸ‘Ž</span><span>Deprecated: It is impossible to use this function for accessing memory of a running virtual machine without violating aliasing rules </span></div></span><div class="docblock"><p>Returns a slice corresponding to the data in the region.</p>
<p>Returns <code>None</code> if the region does not support slice-based access.</p>
<h5 id="safety"><a href="#safety">Safety</a></h5>
<p>Unsafe because of possible aliasing.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut_slice" class="method"><h4 class="code-header">unsafe fn <a href="#method.as_mut_slice" class="fn">as_mut_slice</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;</h4></section></summary><span class="item-info"><div class="stab deprecated"><span class="emoji">ðŸ‘Ž</span><span>Deprecated: It is impossible to use this function for accessing memory of a running virtual machine without violating aliasing rules </span></div></span><div class="docblock"><p>Returns a mutable slice corresponding to the data in the region.</p>
<p>Returns <code>None</code> if the region does not support slice-based access.</p>
<h5 id="safety-1"><a href="#safety-1">Safety</a></h5>
<p>Unsafe because of possible aliasing. Mutable accesses performed through the
returned slice are not visible to the dirty bitmap tracking functionality of
the region, and must be manually recorded using the associated bitmap object.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_slice" class="method"><h4 class="code-header">fn <a href="#method.get_slice" class="fn">get_slice</a>(
    &amp;self,
    offset: <a class="struct" href="struct.MemoryRegionAddress.html" title="struct vmm::vstate::memory::MemoryRegionAddress">MemoryRegionAddress</a>,
    count: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;VolatileSlice&lt;'_, &lt;Self::<a class="associatedtype" href="trait.GuestMemoryRegion.html#associatedtype.B" title="type vmm::vstate::memory::GuestMemoryRegion::B">B</a> as WithBitmapSlice&lt;'_&gt;&gt;::S&gt;, Error&gt;</h4></section></summary><div class="docblock"><p>Returns a <a href="struct.VolatileSlice.html"><code>VolatileSlice</code></a> of <code>count</code> bytes starting at
<code>offset</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_volatile_slice" class="method"><h4 class="code-header">fn <a href="#method.as_volatile_slice" class="fn">as_volatile_slice</a>(
    &amp;self
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;VolatileSlice&lt;'_, &lt;Self::<a class="associatedtype" href="trait.GuestMemoryRegion.html#associatedtype.B" title="type vmm::vstate::memory::GuestMemoryRegion::B">B</a> as WithBitmapSlice&lt;'_&gt;&gt;::S&gt;, Error&gt;</h4></section></summary><div class="docblock"><p>Gets a slice of memory for the entire region that supports volatile access.</p>
<h5 id="examples-uses-the-backend-mmap-feature"><a href="#examples-uses-the-backend-mmap-feature">Examples (uses the <code>backend-mmap</code> feature)</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>region = GuestRegionMmap::&lt;()&gt;::from_range(GuestAddress(<span class="number">0x0</span>), <span class="number">0x400</span>, <span class="prelude-val">None</span>)
    .expect(<span class="string">"Could not create guest memory"</span>);
<span class="kw">let </span>slice = region
    .as_volatile_slice()
    .expect(<span class="string">"Could not get volatile slice"</span>);

<span class="kw">let </span>v = <span class="number">42u32</span>;
<span class="kw">let </span>r = slice
    .get_ref::&lt;u32&gt;(<span class="number">0x200</span>)
    .expect(<span class="string">"Could not get reference"</span>);
r.store(v);
<span class="macro">assert_eq!</span>(r.load(), v);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_hugetlbfs" class="method"><h4 class="code-header">fn <a href="#method.is_hugetlbfs" class="fn">is_hugetlbfs</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Show if the region is based on the <code>HugeTLBFS</code>.
Returns Some(true) if the region is backed by hugetlbfs.
None represents that no information is available.</p>
<h5 id="examples-uses-the-backend-mmap-feature-1"><a href="#examples-uses-the-backend-mmap-feature-1">Examples (uses the <code>backend-mmap</code> feature)</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>addr = GuestAddress(<span class="number">0x1000</span>);
<span class="kw">let </span>mem = GuestMemoryMmap::&lt;()&gt;::from_ranges(<span class="kw-2">&amp;</span>[(addr, <span class="number">0x1000</span>)]).unwrap();
<span class="kw">let </span>r = mem.find_region(addr).unwrap();
<span class="macro">assert_eq!</span>(r.is_hugetlbfs(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details></div><h2 id="object-safety" class="section-header">Object Safety<a href="#object-safety" class="anchor">Â§</a></h2><div class="object-safety-info">This trait is <b>not</b> <a href="https://doc.rust-lang.org/nightly/reference/items/traits.html#object-safety">object safe</a>.</div><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">Â§</a></h2><div id="implementors-list"><details class="toggle implementors-toggle"><summary><section id="impl-GuestMemoryRegion-for-GuestRegionMmap%3CB%3E" class="impl"><a href="#impl-GuestMemoryRegion-for-GuestRegionMmap%3CB%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;B&gt; <a class="trait" href="trait.GuestMemoryRegion.html" title="trait vmm::vstate::memory::GuestMemoryRegion">GuestMemoryRegion</a> for GuestRegionMmap&lt;B&gt;<div class="where">where
    B: <a class="trait" href="trait.Bitmap.html" title="trait vmm::vstate::memory::Bitmap">Bitmap</a>,</div></h3></section></summary><div class="impl-items"><section id="associatedtype.B-1" class="associatedtype trait-impl"><a href="#associatedtype.B-1" class="anchor">Â§</a><h4 class="code-header">type <a href="#associatedtype.B" class="associatedtype">B</a> = B</h4></section></div></details></div><script src="../../../trait.impl/vm_memory/guest_memory/trait.GuestMemoryRegion.js" data-ignore-extern-crates="vm_memory" async></script></section></div></main></body></html>